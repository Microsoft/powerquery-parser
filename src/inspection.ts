import { CommonError, isNever, Option, Result, ResultKind } from "./common";
import { Token, TokenPosition } from "./lexer";
import { Ast, ParserContext, ParserError } from "./parser";
import { ParseOk, TriedParse } from "./parser/parser";

// Inspections are done by starting at a given position.
// A given position is either in a token or somewhere between tokens (whitespace).
// If inside a token, that token is either:
//  * in a Ast.TNode (was parsed)
//  * in a Context.Node (in something that failed to finish parsing)
//  * not in anything (hadn't been read yet by the parser)
//
// We can do something with the first two cases.
// The third is outside of the bounds of inspection.
//
// When a position doesn't start on token we find the closest one to the left
// and treat that as our starting point.
//
// Once we have a starting node (either Ast.TNode or Context.Node),
// the inspection is generated by recursing up the parents.
// The recursion path can take three forms:
//  * all nodes are Ast.TNode
//  * all nodes are Context.Node
//  * nodes are initially Ast.TNode, then they become Context.Node

export type TriedInspect = Result<Inspection, CommonError.CommonError>;

export interface Inspection {
    readonly isInEach: boolean;
    readonly isInFunction: boolean;
    readonly isInIdentifierExpression: boolean;
    readonly isInLeftHandAssignment: boolean;
    readonly isInRecord: boolean;
    readonly scope: ReadonlyArray<string>;
}

export interface Position {
    readonly lineNumber: number;
    readonly lineCodeUnit: number;
}

export function tryFrom(position: Position, triedParse: TriedParse): TriedInspect {
    try {
        switch (triedParse.kind) {
            case ResultKind.Ok:
                const parseOk: ParseOk = triedParse.value;
                return {
                    kind: ResultKind.Ok,
                    value: inspect(position, parseOk.nodesById, new Map(), parseOk.leafNodeIds),
                };

            case ResultKind.Err:
                const error: ParserError.TParserError = triedParse.error;
                if (!(error instanceof ParserError.ParserError)) {
                    const details: {} = { error };
                    throw new CommonError.InvariantError(
                        `triedParse is an error, but is not instance of ParserError.ParserError`,
                        details,
                    );
                }
                const parserError: ParserError.ParserError = error;

                return {
                    kind: ResultKind.Ok,
                    value: inspect(
                        position,
                        parserError.context.astNodesById,
                        parserError.context.contextNodesById,
                        parserError.context.leafNodeIds,
                    ),
                };

            default:
                throw isNever(triedParse);
        }
    } catch (e) {
        return {
            kind: ResultKind.Err,
            error: CommonError.ensureCommonError(e),
        };
    }
}

type TXorNode = IXorNode<XorNodeKind.Ast, Ast.TNode> | IXorNode<XorNodeKind.Context, ParserContext.Node>;

const enum XorNodeKind {
    Ast = "Ast",
    Context = "Context",
}

const DefaultInspection: Inspection = {
    isInEach: false,
    isInFunction: false,
    isInIdentifierExpression: false,
    isInLeftHandAssignment: false,
    isInRecord: false,
    scope: [],
};

interface State {
    // Values that are returned at the end of an inspection.
    isInEach: boolean;
    isInFunction: boolean;
    isInIdentifierExpression: boolean;
    isInLeftHandAssignment: boolean;
    isInRecord: boolean;
    scope: string[];

    // Used to generate the inspection result.
    currentXorNode: Option<TXorNode>;
    maybePreviousXorNode: Option<TXorNode>;
    readonly initialXorNode: TXorNode;
    readonly astNodesById: Map<number, Ast.TNode>;
    readonly contextNodesById: Map<number, ParserContext.Node>;
    readonly leafNodeIds: ReadonlyArray<number>;
}

interface IXorNode<Kind, T> {
    readonly kind: Kind & XorNodeKind;
    readonly node: T;
}

function inspect(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Inspection {
    const maybeState: Option<State> = stateFactory(position, astNodesById, contextNodesById, leafNodeIds);
    if (maybeState === undefined) {
        return DefaultInspection;
    }
    const state: State = maybeState;

    while (state.currentXorNode !== undefined) {
        const xorNode: TXorNode = state.currentXorNode;

        switch (xorNode.kind) {
            case XorNodeKind.Ast: {
                inspectAstNode(state, xorNode.node);
                break;
            }

            case XorNodeKind.Context: {
                inspectContextNode(state, xorNode.node);
                break;
            }

            default:
                throw isNever(xorNode);
        }

        state.maybePreviousXorNode = xorNode;
        state.currentXorNode = maybeXorNodeParent(state, xorNode);
    }

    return {
        isInEach: state.isInEach,
        isInFunction: state.isInFunction,
        isInIdentifierExpression: state.isInIdentifierExpression,
        isInLeftHandAssignment: state.isInLeftHandAssignment,
        isInRecord: state.isInRecord,
        scope: state.scope,
    };
}

function inspectAstNode(state: State, node: Ast.TNode): void {
    switch (node.kind) {
        case Ast.NodeKind.EachExpression:
            state.isInEach = true;
            break;

        // IdentifierExpression covers both inclusive and exclusive identifiers
        case Ast.NodeKind.IdentifierExpression:
            state.isInIdentifierExpression = true;
            break;

        case Ast.NodeKind.InvokeExpression:
            state.isInFunction = true;
            break;

        case Ast.NodeKind.RecordExpression:
        case Ast.NodeKind.RecordLiteral:
            state.isInRecord = true;
            break;

        default:
            break;
    }
}

function inspectContextNode(state: State, node: ParserContext.Node): void {
    switch (node.nodeKind) {
        case Ast.NodeKind.EachExpression:
            state.isInEach = true;
            break;

        // IdentifierExpression covers both inclusive and exclusive identifiers
        case Ast.NodeKind.IdentifierExpression:
            state.isInIdentifierExpression = true;
            break;

        case Ast.NodeKind.InvokeExpression:
            state.isInFunction = true;
            break;

        case Ast.NodeKind.RecordExpression:
        case Ast.NodeKind.RecordLiteral:
            state.isInRecord = true;
            break;

        default:
            break;
    }
}

function stateFactory(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<State> {
    const maybeXorNode: Option<TXorNode> = maybeClosestXorNode(position, astNodesById, contextNodesById, leafNodeIds);
    if (maybeXorNode === undefined) {
        return undefined;
    }
    const xorNode: TXorNode = maybeXorNode;

    return {
        isInEach: false,
        isInFunction: false,
        isInIdentifierExpression: false,
        isInLeftHandAssignment: false,
        isInRecord: false,
        scope: [],

        currentXorNode: xorNode,
        initialXorNode: xorNode,
        maybePreviousXorNode: undefined,
        astNodesById,
        contextNodesById,
        leafNodeIds,
    };
}

function maybeXorNodeParent(state: State, xorNode: TXorNode): Option<TXorNode> {
    let maybeParentNodeId: Option<number>;

    switch (xorNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = xorNode.node;
            maybeParentNodeId = astNode.maybeParentId;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = xorNode.node;
            maybeParentNodeId = contextNode.maybeParentId;
            break;
        }

        default:
            throw isNever(xorNode);
    }

    if (maybeParentNodeId === undefined) {
        return undefined;
    }

    const maybeAstParentNode: Option<Ast.TNode> = state.astNodesById.get(maybeParentNodeId);
    if (maybeAstParentNode) {
        return {
            kind: XorNodeKind.Ast,
            node: maybeAstParentNode,
        };
    }

    const maybeContextParentNode: Option<ParserContext.Node> = state.contextNodesById.get(maybeParentNodeId);
    if (maybeContextParentNode) {
        return {
            kind: XorNodeKind.Context,
            node: maybeContextParentNode,
        };
    }

    return undefined;
}

function maybeClosestXorNode(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<TXorNode> {
    let maybeClosestNode: Option<TXorNode>;

    for (const nodeId of leafNodeIds) {
        let maybeCurrentXorNode: Option<TXorNode>;

        const maybeAstNode: Option<Ast.TNode> = astNodesById.get(nodeId);
        if (maybeAstNode) {
            const astNode: Ast.TNode = maybeAstNode;
            maybeCurrentXorNode = {
                kind: XorNodeKind.Ast,
                node: astNode,
            };
        }

        const maybeContextNode: Option<ParserContext.Node> = contextNodesById.get(nodeId);
        if (maybeContextNode) {
            const contextNode: ParserContext.Node = maybeContextNode;
            maybeCurrentXorNode = {
                kind: XorNodeKind.Context,
                node: contextNode,
            };
        }

        // couldn't find nodeId in either astNodesById nor contextNodesById
        if (maybeCurrentXorNode === undefined) {
            const details: {} = { nodeId };
            throw new CommonError.InvariantError(`nodeId wasn't a astNode nor contextNode`, details);
        }
        const currentXorNode: TXorNode = maybeCurrentXorNode;
        maybeClosestNode = closerXorNode(position, maybeCurrentXorNode, currentXorNode);
    }

    return maybeClosestNode;
}

// Assumes both TXorNode parameters are leaf nodes.
function closerXorNode(position: Position, maybeCurrentNode: Option<TXorNode>, newNode: TXorNode): TXorNode {
    if (maybeCurrentNode === undefined) {
        return newNode;
    }
    const currentNode: TXorNode = maybeCurrentNode;

    let currentNodePositionStart: TokenPosition;
    switch (currentNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = currentNode.node;
            currentNodePositionStart = astNode.tokenRange.positionStart;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = currentNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            const tokenStart: Token = contextNode.maybeTokenStart;

            currentNodePositionStart = tokenStart.positionStart;
            break;
        }

        default:
            throw isNever(currentNode);
    }

    let newNodePositionStart: TokenPosition;
    switch (newNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = newNode.node;
            newNodePositionStart = astNode.tokenRange.positionStart;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = newNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            const tokenStart: Token = contextNode.maybeTokenStart;

            newNodePositionStart = tokenStart.positionStart;
            break;
        }

        default:
            throw isNever(newNode);
    }

    // Verifies newTokenPositionStart starts no later than the position argument.
    if (newNodePositionStart.lineNumber > position.lineNumber) {
        return currentNode;
    } else if (
        newNodePositionStart.lineNumber === position.lineNumber &&
        newNodePositionStart.lineCodeUnit > position.lineCodeUnit
    ) {
        return currentNode;
    }

    // Both currentTokenPositionStart and newTokenPositionStart are <= position,
    // so a quick comparison can be done by examining TokenPosition.codeUnit
    return currentNodePositionStart.codeUnit < newNodePositionStart.codeUnit ? newNode : currentNode;
}
