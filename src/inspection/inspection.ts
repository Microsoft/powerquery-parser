import { CommonError, isNever, Option, Result, ResultKind } from "../common";
import { TokenPosition } from "../lexer";
import { Ast, ParserContext, ParserError, TokenRange } from "../parser";
import { ParseOk, TriedParse } from "../parser/parser";

// Inspections are done by starting at a given position.
// A given position is either in a token or somewhere between tokens (whitespace).
// If inside a token, that token is either:
//  * in a Ast.TNode (was parsed)
//  * in a Context.Node (in something that failed to finish parsing)
//  * not in anything (hadn't been read yet by the parser)
//
// We can do something with the first two cases.
// The third is outside of the bounds of inspection.
//
// When a position doesn't start on token we find the closest one to the left
// and treat that as our starting point.
//
// Once we have a starting node (either Ast.TNode or Context.Node),
// the inspection is generated by recursing up the parents.
// The recursion path can take three forms:
//  * all nodes are Ast.TNode
//  * all nodes are Context.Node
//  * nodes are initially Ast.TNode, then they become Context.Node

export type TriedInspect = Result<Inspection, CommonError.CommonError>;

export interface Inspection {
    readonly nodes: ReadonlyArray<INode>;
    readonly scope: ReadonlyArray<string>;
}

export interface Position {
    readonly lineNumber: number;
    readonly lineCodeUnit: number;
}

export const enum NodeKind {
    Record = "Record",
    Each = "EachExpression",
}

export interface INode {
    readonly kind: NodeKind;
    readonly positionStart: TokenPosition;
    readonly maybePositionEnd: Option<TokenPosition>;
}

export interface Record extends INode {
    readonly kind: NodeKind.Record;
}

export interface Each extends INode {
    readonly kind: NodeKind.Each;
}

export function tryFrom(position: Position, triedParse: TriedParse): TriedInspect {
    try {
        switch (triedParse.kind) {
            case ResultKind.Ok:
                const parseOk: ParseOk = triedParse.value;
                return {
                    kind: ResultKind.Ok,
                    value: inspect(position, parseOk.nodesById, new Map(), parseOk.leafNodeIds),
                };

            case ResultKind.Err:
                const error: ParserError.TParserError = triedParse.error;
                if (!(error instanceof ParserError.ParserError)) {
                    const details: {} = { error };
                    throw new CommonError.InvariantError(
                        `triedParse is an error, but is not instance of ParserError.ParserError`,
                        details,
                    );
                }
                const parserError: ParserError.ParserError = error;

                return {
                    kind: ResultKind.Ok,
                    value: inspect(
                        position,
                        parserError.context.astNodesById,
                        parserError.context.contextNodesById,
                        parserError.context.leafNodeIds,
                    ),
                };

            default:
                throw isNever(triedParse);
        }
    } catch (e) {
        return {
            kind: ResultKind.Err,
            error: CommonError.ensureCommonError(e),
        };
    }
}

type TXorNode = IXorNode<XorNodeKind.Ast, Ast.TNode> | IXorNode<XorNodeKind.Context, ParserContext.Node>;

const enum XorNodeKind {
    Ast = "Ast",
    Context = "Context",
}

const DefaultInspection: Inspection = {
    nodes: [],
    scope: [],
};

interface State {
    // Values that are evalauted then returned at the end of an inspection.
    nodes: INode[];
    scope: string[];

    // Used to generate the inspection result.
    currentXorNode: Option<TXorNode>;
    maybePreviousXorNode: Option<TXorNode>;
    readonly position: Position;
    readonly initialXorNode: TXorNode;
    readonly astNodesById: Map<number, Ast.TNode>;
    readonly contextNodesById: Map<number, ParserContext.Node>;
    readonly leafNodeIds: ReadonlyArray<number>;
}

interface IXorNode<Kind, T> {
    readonly kind: Kind & XorNodeKind;
    readonly node: T;
}

function inspect(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Inspection {
    const maybeState: Option<State> = stateFactory(position, astNodesById, contextNodesById, leafNodeIds);
    if (maybeState === undefined) {
        return DefaultInspection;
    }
    const state: State = maybeState;

    while (state.currentXorNode !== undefined) {
        const xorNode: TXorNode = state.currentXorNode;

        switch (xorNode.kind) {
            case XorNodeKind.Ast: {
                inspectAstNode(state, xorNode.node);
                break;
            }

            case XorNodeKind.Context: {
                inspectContextNode(state, xorNode.node);
                break;
            }

            default:
                throw isNever(xorNode);
        }

        state.maybePreviousXorNode = xorNode;
        state.currentXorNode = maybeXorNodeParent(state, xorNode);
    }

    return {
        nodes: state.nodes,
        scope: state.scope,
    };
}

function inspectAstNode(state: State, node: Ast.TNode): void {
    switch (node.kind) {
        case Ast.NodeKind.EachExpression: {
            const tokenRange: TokenRange = node.tokenRange;
            state.nodes.push({
                kind: NodeKind.Each,
                positionStart: tokenRange.positionStart,
                maybePositionEnd: tokenRange.positionEnd,
            });
            break;
        }

        // // IdentifierExpression covers both inclusive and exclusive identifiers
        // case Ast.NodeKind.IdentifierExpression:
        //     state.isInIdentifierExpression = true;
        //     break;

        // case Ast.NodeKind.InvokeExpression:
        //     state.isInFunction = true;
        //     break;

        case Ast.NodeKind.RecordExpression:
        case Ast.NodeKind.RecordLiteral: {
            // Check if position is on closeWrapperConstant, eg. ']'
            const tokenRange: TokenRange = node.tokenRange;
            if (!isPositionOnTokenPosition(state.position, tokenRange.positionEnd)) {
                state.nodes.push({
                    kind: NodeKind.Record,
                    positionStart: tokenRange.positionStart,
                    maybePositionEnd: tokenRange.positionEnd,
                });
            }
            break;
        }

        default:
            break;
    }
}

function isPositionOnTokenPosition(position: Position, tokenPosition: TokenPosition): boolean {
    return tokenPosition.lineNumber === position.lineNumber && tokenPosition.lineCodeUnit === position.lineCodeUnit;
}

function inspectContextNode(_: State, __: ParserContext.Node): void {
    throw new Error(`todo`);
    // switch (node.nodeKind) {
    //     case Ast.NodeKind.EachExpression:
    //         state.isInEach = true;
    //         break;

    //     // IdentifierExpression covers both inclusive and exclusive identifiers
    //     case Ast.NodeKind.IdentifierExpression:
    //         state.isInIdentifierExpression = true;
    //         break;

    //     case Ast.NodeKind.InvokeExpression:
    //         state.isInFunction = true;
    //         break;

    //     case Ast.NodeKind.RecordExpression:
    //     case Ast.NodeKind.RecordLiteral:
    //         state.isInRecord = true;
    //         break;

    //     default:
    //         break;
    // }
}

function stateFactory(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<State> {
    const maybeXorNode: Option<TXorNode> = maybeClosestXorNode(position, astNodesById, contextNodesById, leafNodeIds);
    if (maybeXorNode === undefined) {
        return undefined;
    }
    const xorNode: TXorNode = maybeXorNode;

    return {
        nodes: [],
        scope: [],

        position,
        currentXorNode: xorNode,
        initialXorNode: xorNode,
        maybePreviousXorNode: undefined,
        astNodesById,
        contextNodesById,
        leafNodeIds,
    };
}

function maybeXorNodeParent(state: State, xorNode: TXorNode): Option<TXorNode> {
    let maybeParentNodeId: Option<number>;

    switch (xorNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = xorNode.node;
            maybeParentNodeId = astNode.maybeParentId;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = xorNode.node;
            maybeParentNodeId = contextNode.maybeParentId;
            break;
        }

        default:
            throw isNever(xorNode);
    }

    if (maybeParentNodeId === undefined) {
        return undefined;
    }

    const maybeAstParentNode: Option<Ast.TNode> = state.astNodesById.get(maybeParentNodeId);
    if (maybeAstParentNode) {
        return {
            kind: XorNodeKind.Ast,
            node: maybeAstParentNode,
        };
    }

    const maybeContextParentNode: Option<ParserContext.Node> = state.contextNodesById.get(maybeParentNodeId);
    if (maybeContextParentNode) {
        return {
            kind: XorNodeKind.Context,
            node: maybeContextParentNode,
        };
    }

    return undefined;
}

function maybeClosestXorNode(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<TXorNode> {
    let maybeClosestNode: Option<TXorNode>;

    for (const nodeId of leafNodeIds) {
        let maybeNewXorNode: Option<TXorNode>;

        const maybeAstNode: Option<Ast.TNode> = astNodesById.get(nodeId);
        if (maybeAstNode) {
            const astNode: Ast.TNode = maybeAstNode;
            maybeNewXorNode = {
                kind: XorNodeKind.Ast,
                node: astNode,
            };
        }

        const maybeContextNode: Option<ParserContext.Node> = contextNodesById.get(nodeId);
        if (maybeContextNode) {
            const contextNode: ParserContext.Node = maybeContextNode;
            maybeNewXorNode = {
                kind: XorNodeKind.Context,
                node: contextNode,
            };
        }

        // couldn't find nodeId in either astNodesById nor contextNodesById
        if (maybeNewXorNode === undefined) {
            const details: {} = { nodeId };
            throw new CommonError.InvariantError(`nodeId wasn't a astNode nor contextNode`, details);
        }
        const newNode: TXorNode = maybeNewXorNode;

        maybeClosestNode = closerXorNode(position, maybeClosestNode, newNode);
    }

    return maybeClosestNode;
}

// Assumes both TXorNode parameters are leaf nodes.
function closerXorNode(position: Position, maybeCurrentNode: Option<TXorNode>, newNode: TXorNode): Option<TXorNode> {
    const newNodePositionStart: TokenPosition = expectTokenStart(newNode);

    // If currentToken isn't set and newNode's start position is <= position: return newToken
    // Else: return undefined
    if (maybeCurrentNode === undefined) {
        if (newNodePositionStart.lineNumber > position.lineNumber) {
            return undefined;
        } else if (
            newNodePositionStart.lineNumber === position.lineNumber &&
            newNodePositionStart.lineCodeUnit >= position.lineCodeUnit
        ) {
            return undefined;
        } else {
            return newNode;
        }
    }
    const currentNode: TXorNode = maybeCurrentNode;
    const currentNodePositionStart: TokenPosition = expectTokenStart(currentNode);

    // Verifies newTokenPositionStart starts no later than the position argument.
    if (newNodePositionStart.lineNumber > position.lineNumber) {
        return currentNode;
    } else if (
        newNodePositionStart.lineNumber === position.lineNumber &&
        newNodePositionStart.lineCodeUnit > position.lineCodeUnit
    ) {
        return currentNode;
    }

    // Both currentTokenPositionStart and newTokenPositionStart are <= position,
    // so a quick comparison can be done by examining TokenPosition.codeUnit
    return currentNodePositionStart.codeUnit < newNodePositionStart.codeUnit ? newNode : currentNode;
}

function expectTokenStart(xorNode: TXorNode): TokenPosition {
    switch (xorNode.kind) {
        case XorNodeKind.Ast:
            return xorNode.node.tokenRange.positionStart;

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = xorNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            return contextNode.maybeTokenStart.positionStart;
        }

        default:
            throw isNever(xorNode);
    }
}
