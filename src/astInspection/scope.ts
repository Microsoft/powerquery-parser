import { CommonError, isNever, Option } from "../common";
import { Token, TokenPosition } from "../lexer";
import { Ast, ParserContext } from "../parser";

// Inspections are done by starting at a given position.
// A given position is either in a token or somewhere between tokens (whitespace).
// If inside a token, that token is either:
//  * in a Ast.TNode (was parsed)
//  * in a Context.Node (in something that failed to finish parsing)
//  * not in anything (hadn't been read yet by the parser)
//
// We can do something with the first two cases.
// The third is outside of the bounds of inspection.
//
// When a position doesn't start on token we find the closest one to the left
// and treat that as our starting point.
//
// Once we have a starting node (either Ast.TNode or Context.Node),
// the inspection is generated by recursing up the parents.
// The recursion path can take three forms:
//  * all nodes are Ast.TNode
//  * all nodes are Context.Node
//  * nodes are initially Ast.TNode, then they become Context.Node

export interface Inspection {
    readonly isInEach: boolean;
    readonly isInFunction: boolean;
    readonly isInLeftHandAssignment: boolean;
    readonly isInRecord: boolean;
    readonly isOnIdentifier: boolean;
    readonly scope: ReadonlyArray<string>;
}

export interface Position {
    readonly lineNumber: number;
    readonly lineCodeUnit: number;
}

export function inspect(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<Inspection> {
    const maybeState: Option<State> = stateFactory(position, astNodesById, contextNodesById, leafNodeIds);
    if (maybeState === undefined) {
        return undefined;
    }
    const state: State = maybeState;

    let maybeXorNode: Option<TXorNode> = state.initialXorNode;
    while (maybeXorNode !== undefined) {
        const xorNode: TXorNode = maybeXorNode;
        maybeXorNode = maybeXorNodeParent(state, xorNode);
    }

    return {
        isInEach: state.isInEach,
        isInFunction: state.isInFunction,
        isInLeftHandAssignment: state.isInLeftHandAssignment,
        isInRecord: state.isInRecord,
        isOnIdentifier: state.isOnIdentifier,
        scope: state.scope,
    };
}

type TXorNode = IXorNode<XorNodeKind.Ast, Ast.TNode> | IXorNode<XorNodeKind.Context, ParserContext.Node>;

const enum XorNodeKind {
    Ast = "Ast",
    Context = "Context",
}

interface State {
    // Values that are returned at the end of an inspection.
    isInEach: boolean;
    isInFunction: boolean;
    isInLeftHandAssignment: boolean;
    isInRecord: boolean;
    isOnIdentifier: boolean;
    scope: string[];

    // Used to generate the inspection result.
    readonly initialXorNode: TXorNode;
    readonly astNodesById: Map<number, Ast.TNode>;
    readonly contextNodesById: Map<number, ParserContext.Node>;
    readonly leafNodeIds: ReadonlyArray<number>;
}

interface IXorNode<Kind, T> {
    readonly kind: Kind & XorNodeKind;
    readonly node: T;
}

function stateFactory(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<State> {
    const maybeXorNode: Option<TXorNode> = maybeClosestXorNode(position, astNodesById, contextNodesById, leafNodeIds);
    if (maybeXorNode === undefined) {
        return undefined;
    }
    const xorNode: TXorNode = maybeXorNode;

    return {
        isInEach: false,
        isInFunction: false,
        isInLeftHandAssignment: false,
        isInRecord: false,
        isOnIdentifier: false,
        scope: [],

        initialXorNode: xorNode,
        astNodesById,
        contextNodesById,
        leafNodeIds,
    };
}

function maybeXorNodeParent(state: State, xorNode: TXorNode): Option<TXorNode> {
    let maybeParentNodeId: Option<number>;

    switch (xorNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = xorNode.node;
            maybeParentNodeId = astNode.maybeParentId;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = xorNode.node;
            maybeParentNodeId = contextNode.maybeParentId;
            break;
        }

        default:
            throw isNever(xorNode);
    }

    if (maybeParentNodeId === undefined) {
        return undefined;
    }

    const maybeAstParentNode: Option<Ast.TNode> = state.astNodesById.get(maybeParentNodeId);
    if (maybeAstParentNode) {
        return {
            kind: XorNodeKind.Ast,
            node: maybeAstParentNode,
        };
    }

    const maybeContextParentNode: Option<ParserContext.Node> = state.contextNodesById.get(maybeParentNodeId);
    if (maybeContextParentNode) {
        return {
            kind: XorNodeKind.Context,
            node: maybeContextParentNode,
        };
    }

    return undefined;
}

function maybeClosestXorNode(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    leafNodeIds: ReadonlyArray<number>,
): Option<TXorNode> {
    let maybeClosestNode: Option<TXorNode>;

    for (const nodeId of leafNodeIds) {
        let maybeCurrentXorNode: Option<TXorNode>;

        const maybeAstNode: Option<Ast.TNode> = astNodesById.get(nodeId);
        if (maybeAstNode) {
            const astNode: Ast.TNode = maybeAstNode;
            maybeCurrentXorNode = {
                kind: XorNodeKind.Ast,
                node: astNode,
            };
        }

        const maybeContextNode: Option<ParserContext.Node> = contextNodesById.get(nodeId);
        if (maybeContextNode) {
            const contextNode: ParserContext.Node = maybeContextNode;
            maybeCurrentXorNode = {
                kind: XorNodeKind.Context,
                node: contextNode,
            };
        }

        // couldn't find nodeId in either astNodesById nor contextNodesById
        if (maybeCurrentXorNode === undefined) {
            const details: {} = { nodeId };
            throw new CommonError.InvariantError(`nodeId wasn't a astNode nor contextNode`, details);
        }
        const currentXorNode: TXorNode = maybeCurrentXorNode;
        maybeClosestNode = closerXorNode(position, maybeCurrentXorNode, currentXorNode);
    }

    return maybeClosestNode;
}

// Assumes both TXorNode parameters are leaf nodes.
function closerXorNode(position: Position, maybeCurrentNode: Option<TXorNode>, newNode: TXorNode): TXorNode {
    if (maybeCurrentNode === undefined) {
        return newNode;
    }
    const currentNode: TXorNode = maybeCurrentNode;

    let currentNodePositionStart: TokenPosition;
    switch (currentNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = currentNode.node;
            currentNodePositionStart = astNode.tokenRange.positionStart;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = currentNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            const tokenStart: Token = contextNode.maybeTokenStart;

            currentNodePositionStart = tokenStart.positionStart;
            break;
        }

        default:
            throw isNever(currentNode);
    }

    let newNodePositionStart: TokenPosition;
    switch (newNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = newNode.node;
            newNodePositionStart = astNode.tokenRange.positionStart;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = newNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            const tokenStart: Token = contextNode.maybeTokenStart;

            newNodePositionStart = tokenStart.positionStart;
            break;
        }

        default:
            throw isNever(newNode);
    }

    // Verifies newTokenPositionStart starts no later than the position argument.
    if (newNodePositionStart.lineNumber > position.lineNumber) {
        return currentNode;
    } else if (
        newNodePositionStart.lineNumber === position.lineNumber &&
        newNodePositionStart.lineCodeUnit > position.lineCodeUnit
    ) {
        return currentNode;
    }

    // Both currentTokenPositionStart and newTokenPositionStart are <= position,
    // so a quick comparison can be done by examining TokenPosition.codeUnit
    return currentNodePositionStart.codeUnit < newNodePositionStart.codeUnit ? newNode : currentNode;
}
