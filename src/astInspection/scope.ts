import { CommonError, isNever, Option } from "../common";
import { Token, TokenPosition } from "../lexer";
import { Ast, ParserContext } from "../parser";
/* tslint:disable */

// Inspections are done by starting at a given position.
// A given position is either in a token or somewhere between tokens (whitespace).
// If inside a token, that token is either:
//  * in a Ast.TNode (was parsed)
//  * in a Context.Node (in something that failed to finish parsing)
//  * not in anything (hadn't been read yet by the parser)
//
// We can do something with the first two cases.
// The third is outside of the bounds of inspection.
//
// When a position doesn't start on token we find the closest one to the left
// and treat that as our starting point.
//
// Once we have a starting node (either Ast.TNode or Context.Node) the inspection is generated by recursing up the parents.
// The recursion path can take three forms:
//  * all nodes are Ast.TNode
//  * all nodes are Context.Node
//  * nodes are initially Ast.TNode, then they become Context.Node

interface Position {
    readonly lineNumber: number;
    readonly lineCodeUnit: number;
}

const enum XorNodeKind {
    Ast = "Ast",
    Context = "Context",
}

interface InspectionState {
    // Values that are returned at the end of an inspection.
    scope: string[];
    isIdentifier: boolean;
    isLeftHandAssignment: boolean;
    inRecord: boolean;
    inEach: boolean;
    inFunction: boolean;
    tokenRangeStart: number;
    tokenRangeEnd: number;

    // The internal state of the inspection.
    xorNode: TXorNode;
    astNodesById: Map<number, Ast.TNode>;
    contextNodesById: Map<number, ParserContext.Node>;
}

type TXorNode = IXorNode<XorNodeKind.Ast, Ast.TNode> | IXorNode<XorNodeKind.Context, ParserContext.Node>;

interface IXorNode<Kind, T> {
    readonly kind: Kind & XorNodeKind;
    readonly node: T;
}

function maybeGetXorNodeParent(state: InspectionState): Option<TXorNode> {
    let maybeParentNodeId: Option<number>;

    switch (state.xorNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = state.xorNode.node;
            maybeParentNodeId = astNode.maybeParentId;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = state.xorNode.node;
            maybeParentNodeId = contextNode.maybeParentId;
            break;
        }

        default:
            throw isNever(state.xorNode);
    }

    if (maybeParentNodeId === undefined) {
        return undefined;
    }

    const maybeAstParentNode: Option<Ast.TNode> = state.astNodesById.get(maybeParentNodeId);
    if (maybeAstParentNode) {
        return {
            kind: XorNodeKind.Ast,
            node: maybeAstParentNode,
        };
    }

    const maybeContextParentNode: Option<ParserContext.Node> = state.contextNodesById.get(maybeParentNodeId);
    if (maybeContextParentNode) {
        return {
            kind: XorNodeKind.Context,
            node: maybeContextParentNode,
        };
    }

    return undefined;
}

function closestNode(
    position: Position,
    astNodesById: Map<number, Ast.TNode>,
    contextNodesById: Map<number, ParserContext.Node>,
    terminalNodeIds: ReadonlyArray<number>,
): TXorNode {
    let maybeClosestNode: Option<TXorNode>;

    for (const nodeId of terminalNodeIds) {
        let maybeXorNode: Option<TXorNode>;

        const maybeAstNode: Option<Ast.TNode> = astNodesById.get(nodeId);
        if (maybeAstNode) {
            const astNode: Ast.TNode = maybeAstNode;
            maybeXorNode = {
                kind: XorNodeKind.Ast,
                node: astNode,
            };
        }

        const maybeContextNode: Option<ParserContext.Node> = contextNodesById.get(nodeId);
        if (maybeContextNode) {
            const contextNode: ParserContext.Node = maybeContextNode;
            maybeXorNode = {
                kind: XorNodeKind.Context,
                node: contextNode,
            };
        }

        // couldn't find nodeId in either astNodesById nor contextNodesById
        if (maybeXorNode === undefined) {
            const details: {} = { nodeId };
            throw new CommonError.InvariantError(`nodeId wasn't a astNode nor contextNode`, details);
        }
    }
}

function isXorNodeCloser(position: Position, maybeCurrentNode: Option<TXorNode>, newNode: TXorNode) {
    if (maybeCurrentNode === undefined) {
        return newNode;
    }
    const currentNode: TXorNode = maybeCurrentNode;

    let currentTokenPositionStart: TokenPosition;
    switch (currentNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = currentNode.node;
            currentTokenPositionStart = astNode.tokenRange.positionStart;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = currentNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            const tokenStart: Token = contextNode.maybeTokenStart;

            currentTokenPositionStart = tokenStart.positionStart;
            break;
        }

        default:
            throw isNever(currentNode);
    }

    let newTokenPositionStart: TokenPosition;
    switch (currentNode.kind) {
        case XorNodeKind.Ast: {
            const astNode: Ast.TNode = currentNode.node;
            newTokenPositionStart = astNode.tokenRange.positionStart;
            break;
        }

        case XorNodeKind.Context: {
            const contextNode: ParserContext.Node = currentNode.node;
            if (!contextNode.maybeTokenStart) {
                const details: {} = { nodeId: contextNode.nodeId };
                throw new CommonError.InvariantError(`contextNode.maybeTokenStart should be truthy`, details);
            }
            const tokenStart: Token = contextNode.maybeTokenStart;

            newTokenPositionStart = tokenStart.positionStart;
            break;
        }

        default:
            throw isNever(currentNode);
    }
}

// function inspectContextState(contextState: ParserContext.State) {}

// function inspectionStateFactory(
//     position: Position,
//     astNodesById: Map<number, Ast.TNode>,
//     contextNodesById: Map<number, ParserContext.Node>,
// ): InspectionState {}

// // function inspectParseOk(parseOk: ParseOk, position: Position) {
// //     const terminalNode: Ast.TNode = expectAstTerminalNode(parseOk.nodesById, parseOk.terminalNodeIds, position);
// // }

// // function inspectAstNode(inspectionState: InspectionState, node: Ast.TNode, nodesById: Map<number, ParserContext.Node>) {
// //     let maybeNode: Option<Ast.TNode> = node;

// //     while (maybeNode) {
// //         const node: Ast.TNode = maybeNode;

// //         switch (node.kind) {
// //             case Ast.NodeKind.EachExpression:
// //                 if (!inspectionState.inEach) {
// //                     inspectionState.scope.push("_");
// //                 }
// //                 inspectionState.inEach = true;
// //                 break;

// //             case Ast.NodeKind.GeneralizedIdentifier:
// //                 inspectionState.scope.push(node.literal);
// //                 break;

// //             case Ast.NodeKind.Identifier:
// //                 inspectionState.scope.push(node.literal);
// //                 break;
// //         }

// //         if (node.maybeParentId === undefined) {
// //             maybeNode = undefined;
// //         } else {
// //             const parentId: number = node.maybeParentId;
// //             maybeNode = nodesById.get(parentId);
// //         }
// //     }
// // }

// function expectAstTerminalNode(
//     nodesById: Map<number, Ast.TNode>,
//     terminalNodeIds: ReadonlyArray<number>,
//     position: Position,
// ): Ast.TNode {
//     for (const nodeId of terminalNodeIds) {
//         const maybeNode: Option<Ast.TNode> = nodesById.get(nodeId);
//         if (maybeNode === undefined) {
//             throw new CommonError.InvariantError(
//                 `All terminalNodeIds should be in nodesById. Missing nodeId: ${nodeId}`,
//             );
//         }
//         const node: Ast.TNode = maybeNode;
//         const tokenRange: TokenRange = node.tokenRange;
//         if (isInRange(position, tokenRange)) {
//             return node;
//         }
//     }

//     return undefined;

//     // throw new CommonError.InvariantError(
//     //     `Could not find a terminal node at given position: position=${JSON.stringify(position)}`,
//     // );
// }

// function expectTerminalNode(
//     astNodesById: Map<number, Ast.TNode>,
//     contextNodesById: Map<number, ParserContext.Node>,
//     terminalNodeIds: ReadonlyArray<number>,
//     position: Position,
// ): Ast.TNode {
//     for (const nodeId of terminalNodeIds) {
//         if (contextNodesById.has(nodeId)) {
//             const contextNode: ParserContext.Node = contextNodesById.get(nodeId) as ParserContext.Node;
//             if (contextNode.maybeAstNode === undefined) {
//                 throw new CommonError.InvariantError(
//                     `maybeAstNode should be truthy. The nodeId=${nodeId} should've been placed in terminalNodeIds as the context was ending.`,
//                 );
//             }

//             const astNode: Ast.TNode = contextNode.maybeAstNode;
//             const tokenRange: TokenRange = astNode.tokenRange;
//             if (isInRange(position, tokenRange)) {
//                 return astNode;
//             }
//         }

//     }

//     return undefined;

//     // throw new CommonError.InvariantError(
//     //     `Could not find a terminal node at given position: position=${JSON.stringify(position)}`,
//     // );
// }

// function isInRange(position: Position, tokenRange: TokenRange): boolean {
//     const positionStart: TokenPosition = tokenRange.positionStart;
//     const positionEnd: TokenPosition = tokenRange.positionEnd;

//     return (
//         positionStart.lineNumber >= position.lineNumber &&
//         positionEnd.lineNumber <= position.lineNumber &&
//         positionStart.lineCodeUnit >= position.lineCodeUnit &&
//         positionEnd.lineCodeUnit >= position.lineCodeUnit
//     );
// }
